use super::base *;
use crate::data::types::{StrategyResult, Trade};
use crate::engines::evaluation::Backtester;
use crate::engines::generation::ast::StrategyAST;
use crate::engines::metrics::engine::MetricsEngine;
use crate::error::TradebiasError;
use polars::prelude::*;
use rand::seq::SliceRandom;
use rand::SeedableRng;
use rand::rngs::StdRng;
use serde_json::json;

pub struct MonteCarloTest {
    n_simulations: usize,
    metric_name: String, // e.g., "sharpe_ratio"
    seed: Option<u64>,
}

impl MonteCarloTest {
    pub fn new(n_simulations: usize, metric_name: String) -> Self {
        Self {
            n_simulations,
            metric_name,
            seed: Some(42),
        }
    }
}

impl RobustnessTest for MonteCarloTest {
    fn name(&self) -> &str {
        "Monte Carlo (Trade Permutation)"
    }

    fn description(&self) -> &str {
        "Tests if strategy performance is due to skill or random luck by randomly shuffling trade outcomes"
    }

    fn run(
        &self,
        ast: &StrategyAST,
        data: &DataFrame,
        backtester: &Backtester,
    ) -> Result<TestResult, TradebiasError> {
        // Run original backtest
        let original_result = backtester.run(ast, data)?;
        let original_metric = original_result
            .metrics
            .get(&self.metric_name)
            .copied()
            .unwrap_or(0.0);

        // Extract trade P&Ls
        let trade_pnls: Vec<f64> = original_result
            .trades
            .iter()
            .map(|t| t.profit_loss)
            .collect();

        if trade_pnls.is_empty() {
            return Ok(TestResult {
                test_name: self.name().to_string(),
                passed: false,
                score: 0.0,
                details: json!({
                    "error": "No trades generated by strategy"
                }),
                interpretation: "Cannot perform Monte Carlo test without trades".to_string(),
            });
        }

        // Run simulations
        let mut rng = match self.seed {
            Some(seed) => StdRng::seed_from_u64(seed),
            None => StdRng::from_entropy(),
        };

        let mut simulated_metrics = Vec::new();

        for _ in 0..self.n_simulations {
            // Shuffle trades
            let mut shuffled_pnls = trade_pnls.clone();
            shuffled_pnls.shuffle(&mut rng);

            // Recalculate equity curve
            let initial_capital = original_result.initial_capital;
            let equity_curve = self.calculate_equity_curve(initial_capital, &shuffled_pnls);

            // Calculate metric for shuffled sequence
            let metric = self.calculate_metric_from_equity(&equity_curve);
            simulated_metrics.push(metric);
        }

        // Sort simulations
        simulated_metrics.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));

        // Calculate percentile of original
        let percentile = self.calculate_percentile(&simulated_metrics, original_metric);

        // Pass if original is in top 5% (95th percentile or higher)
        let passed = percentile >= 95.0;
        let score = (percentile / 100.0).max(0.0).min(1.0);

        // Calculate statistics
        let mean = simulated_metrics.iter().sum::<f64>() / simulated_metrics.len() as f64;
        let p5 = simulated_metrics[(simulated_metrics.len() as f64 * 0.05) as usize];
        let p50 = simulated_metrics[simulated_metrics.len() / 2];
        let p95 = simulated_metrics[(simulated_metrics.len() as f64 * 0.95) as usize];

        let interpretation = if passed {
            format!(
                "Strategy performance ({}th percentile) is significantly better than random chance. "
                "Original {} = {:.2}, vs random mean = {:.2}",
                percentile as u32,
                self.metric_name,
                original_metric,
                mean
            )
        } else {
            format!(
                "WARNING: Strategy performance ({}th percentile) may be due to luck. "
                "Original {} = {:.2}, vs random mean = {:.2}",
                percentile as u32,
                self.metric_name,
                original_metric,
                mean
            )
        };

        Ok(TestResult {
            test_name: self.name().to_string(),
            passed,
            score,
            details: json!({
                "original_metric": original_metric,
                "metric_name": self.metric_name,
                "percentile": percentile,
                "simulations": self.n_simulations,
                "simulation_stats": {
                    "mean": mean,
                    "p5": p5,
                    "p50": p50,
                    "p95": p95,
                }
            }),
            interpretation,
        })
    }
}

impl MonteCarloTest {
    fn calculate_equity_curve(&self, initial_capital: f64, pnls: &[f64]) -> Vec<f64> {
        let mut equity = vec![initial_capital];
        let mut current = initial_capital;

        for &pnl in pnls {
            current += pnl;
            equity.push(current);
        }

        equity
    }

    fn calculate_metric_from_equity(&self, equity_curve: &[f64]) -> f64 {
        // Simplified metric calculation (Sharpe-like)
        if equity_curve.len() < 2 {
            return 0.0;
        }

        let returns: Vec<f64> = equity_curve
            .windows(2)
            .map(|w| (w[1] - w[0]) / w[0])
            .collect();

        if returns.is_empty() {
            return 0.0;
        }

        let mean_return = returns.iter().sum::<f64>() / returns.len() as f64;
        let variance = returns
            .iter()
            .map(|r| (r - mean_return).powi(2))
            .sum::<f64>() / (returns.len() - 1) as f64;

        let std_dev = variance.sqrt();

        if std_dev == 0.0 {
            return 0.0;
        }

        // Annualized Sharpe (assuming 252 trading days)
        let sharpe = (mean_return / std_dev) * (252.0_f64).sqrt();
        sharpe
    }

    fn calculate_percentile(&self, sorted_values: &[f64], value: f64) -> f64 {
        let count = sorted_values.iter().filter(|&&v| v < value).count();
        (count as f64 / sorted_values.len() as f64) * 100.0
    }
}
