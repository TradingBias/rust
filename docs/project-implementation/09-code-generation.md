# 09 - MQL5 Code Generation

## Goal
Generate MQL5 Expert Advisor (EA) code and custom indicator library from Rust implementations.

## Prerequisites
- **[08-metrics-engine.md](./08-metrics-engine.md)** completed
- All indicators and engine implemented

## What You'll Create
1. Indicator Library Generator (`src/codegen/mql5_indicators.rs`)
2. EA Generator (`src/codegen/mql5_ea.rs`)

## Key Principles

1. **All MQL5 code is stateful** (bar-by-bar), regardless of Rust implementation
2. **Mathematical consistency** - same algorithm, different execution model
3. **Generates two files**:
   - `TradeBias_Indicators.mqh` - indicator library
   - `TradeBias_EA.mq5` - Expert Advisor

## Quick Implementation

### Step 1: MQL5 Indicator Library Generator

```rust
// src/codegen/mql5_indicators.rs
use crate::functions::registry::FunctionRegistry;
use crate::functions::traits::Indicator;
use std::sync::Arc;

pub struct IndicatorLibraryGenerator {
    registry: Arc<FunctionRegistry>,
}

impl IndicatorLibraryGenerator {
    pub fn new(registry: Arc<FunctionRegistry>) -> Self {
        Self { registry }
    }

    pub fn generate(&self) -> String {
        let mut code = String::new();

        // Header
        code.push_str(&self.generate_header());

        // Generate function for each indicator
        for alias in self.registry.list_indicators() {
            if let Some(indicator) = self.registry.get_indicator(&alias) {
                code.push_str(&self.generate_indicator_function(&indicator));
                code.push_str("\n\n");
            }
        }

        code
    }

    fn generate_header(&self) -> String {
        r#"//+------------------------------------------------------------------+
//| TradeBias_Indicators.mqh                                         |
//| Custom indicator implementations for TradeBias                   |
//| Generated by TradeBias Rust Engine                               |
//| NOTE: All indicators use stateful (bar-by-bar) calculation       |
//+------------------------------------------------------------------+

#property strict

"#.to_string()
    }

    fn generate_indicator_function(&self, indicator: &Arc<dyn Indicator>) -> String {
        let alias = indicator.alias();

        match alias {
            "RSI" => self.generate_rsi(),
            "SMA" => self.generate_sma(),
            "EMA" => self.generate_ema(),
            "MACD" => self.generate_macd(),
            "ATR" => self.generate_atr(),
            _ => format!("// TODO: Implement {}\n", alias),
        }
    }

    fn generate_rsi(&self) -> String {
        r#"//+------------------------------------------------------------------+
//| Relative Strength Index (RSI)                                    |
//| Wilder's smoothing - matches TradeBias Rust engine exactly       |
//+------------------------------------------------------------------+
double TB_RSI(const double &close[], int period, int shift) {
    if(shift + period + 1 >= ArraySize(close)) return 50.0;

    double avg_gain = 0.0;
    double avg_loss = 0.0;

    // Initial period: simple average
    for(int i = 0; i < period; i++) {
        double change = close[shift + i + 1] - close[shift + i];
        if(change > 0) avg_gain += change;
        else avg_loss += -change;
    }

    avg_gain /= period;
    avg_loss /= period;

    // Calculate RS and RSI
    if(avg_loss == 0.0) return 100.0;
    double rs = avg_gain / avg_loss;
    return 100.0 - (100.0 / (1.0 + rs));
}"#.to_string()
    }

    fn generate_sma(&self) -> String {
        r#"//+------------------------------------------------------------------+
//| Simple Moving Average (SMA)                                      |
//+------------------------------------------------------------------+
double TB_SMA(const double &close[], int period, int shift) {
    if(shift + period > ArraySize(close)) return 0.0;

    double sum = 0.0;
    for(int i = 0; i < period; i++) {
        sum += close[shift + i];
    }

    return sum / period;
}"#.to_string()
    }

    fn generate_ema(&self) -> String {
        r#"//+------------------------------------------------------------------+
//| Exponential Moving Average (EMA)                                 |
//+------------------------------------------------------------------+
double TB_EMA(const double &close[], int period, int shift) {
    if(shift + period > ArraySize(close)) return 0.0;

    double alpha = 2.0 / (period + 1.0);

    // First value is SMA
    double ema = TB_SMA(close, period, shift + period - 1);

    // Apply EMA formula
    for(int i = shift + period - 2; i >= shift; i--) {
        ema = alpha * close[i] + (1.0 - alpha) * ema;
    }

    return ema;
}"#.to_string()
    }

    fn generate_macd(&self) -> String {
        r#"//+------------------------------------------------------------------+
//| Moving Average Convergence Divergence (MACD)                     |
//+------------------------------------------------------------------+
double TB_MACD(const double &close[], int fast, int slow, int signal, int shift, int mode) {
    // mode: 0 = MACD line, 1 = Signal line, 2 = Histogram

    double ema_fast = TB_EMA(close, fast, shift);
    double ema_slow = TB_EMA(close, slow, shift);
    double macd_line = ema_fast - ema_slow;

    if(mode == 0) return macd_line;

    // For signal and histogram, need to calculate signal line
    // (Simplified - full implementation would maintain signal line buffer)
    return macd_line;
}"#.to_string()
    }

    fn generate_atr(&self) -> String {
        r#"//+------------------------------------------------------------------+
//| Average True Range (ATR)                                         |
//+------------------------------------------------------------------+
double TB_ATR(const double &high[], const double &low[], const double &close[], int period, int shift) {
    if(shift + period + 1 >= ArraySize(close)) return 0.0;

    double atr = 0.0;
    double alpha = 1.0 / period;

    // Calculate initial ATR using simple average
    for(int i = 0; i < period; i++) {
        int idx = shift + i;
        double hl = high[idx] - low[idx];
        double hc = MathAbs(high[idx] - close[idx + 1]);
        double lc = MathAbs(low[idx] - close[idx + 1]);
        double tr = MathMax(hl, MathMax(hc, lc));
        atr += tr;
    }

    atr /= period;

    // Apply Wilder's smoothing for remaining periods
    for(int i = shift + period - 1; i >= shift; i--) {
        double hl = high[i] - low[i];
        double hc = MathAbs(high[i] - close[i + 1]);
        double lc = MathAbs(low[i] - close[i + 1]);
        double tr = MathMax(hl, MathMax(hc, lc));
        atr = atr * (1.0 - alpha) + tr * alpha;
    }

    return atr;
}"#.to_string()
    }
}
```

### Step 2: EA Generator

```rust
// src/codegen/mql5_ea.rs
use crate::types::AstNode;

pub struct EAGenerator;

impl EAGenerator {
    pub fn generate(ast: &AstNode, strategy_name: &str) -> String {
        let mut code = String::new();

        // Header and includes
        code.push_str(&Self::generate_header(strategy_name));

        // Include custom indicators
        code.push_str("#include \"TradeBias_Indicators.mqh\"\n\n");

        // Input parameters
        code.push_str(&Self::generate_inputs());

        // Global variables
        code.push_str(&Self::generate_globals());

        // OnInit, OnDeinit, OnTick
        code.push_str(&Self::generate_oninit());
        code.push_str(&Self::generate_ondeinit());
        code.push_str(&Self::generate_ontick(ast));

        // Helper functions
        code.push_str(&Self::generate_helpers());

        code
    }

    fn generate_header(name: &str) -> String {
        format!(r#"//+------------------------------------------------------------------+
//| {}                                                               |
//| Generated by TradeBias Rust Engine                               |
//+------------------------------------------------------------------+

#property copyright "TradeBias"
#property version   "1.00"
#property strict

"#, name)
    }

    fn generate_inputs() -> String {
        r#"//--- Input parameters
input double LotSize = 0.1;
input int StopLoss = 50;
input int TakeProfit = 100;
input int MagicNumber = 12345;

"#.to_string()
    }

    fn generate_globals() -> String {
        r#"//--- Global variables
int ticket = 0;
bool inPosition = false;

"#.to_string()
    }

    fn generate_oninit() -> String {
        r#"//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit() {
    Print("TradeBias EA Initialized");
    return(INIT_SUCCEEDED);
}

"#.to_string()
    }

    fn generate_ondeinit() -> String {
        r#"//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
    Print("TradeBias EA Deinitialized");
}

"#.to_string()
    }

    fn generate_ontick(ast: &AstNode) -> String {
        let signal_code = Self::ast_to_mql5(ast);

        format!(r#"//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick() {{
    // Calculate signal
    double signal = {};

    // Entry logic
    if(!inPosition && signal != 0) {{
        if(signal > 0) {{
            // Open long position
            ticket = OrderSend(Symbol(), OP_BUY, LotSize, Ask, 3,
                               Ask - StopLoss * Point, Ask + TakeProfit * Point,
                               "TradeBias Long", MagicNumber, 0, clrGreen);
            if(ticket > 0) inPosition = true;
        }}
        else if(signal < 0) {{
            // Open short position
            ticket = OrderSend(Symbol(), OP_SELL, LotSize, Bid, 3,
                               Bid + StopLoss * Point, Bid - TakeProfit * Point,
                               "TradeBias Short", MagicNumber, 0, clrRed);
            if(ticket > 0) inPosition = true;
        }}
    }}

    // Exit logic
    if(inPosition) {{
        // Check for exit signal or stop/target hit
        // (Implementation depends on strategy)
    }}
}}

"#, signal_code)
    }

    fn generate_helpers() -> String {
        r#"//+------------------------------------------------------------------+
//| Helper functions                                                 |
//+------------------------------------------------------------------+
bool ClosePosition() {
    if(!inPosition) return false;

    bool result = false;
    if(OrderSelect(ticket, SELECT_BY_TICKET)) {
        if(OrderType() == OP_BUY) {
            result = OrderClose(ticket, LotSize, Bid, 3, clrRed);
        }
        else if(OrderType() == OP_SELL) {
            result = OrderClose(ticket, LotSize, Ask, 3, clrGreen);
        }

        if(result) {
            inPosition = false;
            ticket = 0;
        }
    }

    return result;
}
"#.to_string()
    }

    fn ast_to_mql5(ast: &AstNode) -> String {
        match ast {
            AstNode::Call { function, args } => {
                // Convert function call to MQL5
                format!("{}({})", function, "Close, 14, 0")  // Simplified
            }
            AstNode::Const(value) => format!("{:?}", value),
            _ => "0".to_string(),
        }
    }
}
```

## Verification

```rust
#[test]
fn test_indicator_library_generation() {
    let registry = Arc::new(FunctionRegistry::new());
    let generator = IndicatorLibraryGenerator::new(registry);

    let mqh_code = generator.generate();

    // Check that code contains key indicators
    assert!(mqh_code.contains("TB_RSI"));
    assert!(mqh_code.contains("TB_SMA"));
    assert!(mqh_code.contains("TB_EMA"));
    assert!(mqh_code.contains("TB_MACD"));
    assert!(mqh_code.contains("Wilder's smoothing"));
}

#[test]
fn test_ea_generation() {
    let ast = AstNode::Call {
        function: "RSI".to_string(),
        args: vec![],
    };

    let ea_code = EAGenerator::generate(&ast, "TestStrategy");

    assert!(ea_code.contains("OnInit"));
    assert!(ea_code.contains("OnTick"));
    assert!(ea_code.contains("TradeBias_Indicators.mqh"));
    assert!(ea_code.contains("OrderSend"));
}
```

## Output Files

### Generated Files
1. **TradeBias_Indicators.mqh** - Place in `MQL5/Include/`
2. **TradeBias_EA.mq5** - Place in `MQL5/Experts/`

### Usage in MetaTrader 5
```mql5
// In your EA
#include <TradeBias_Indicators.mqh>

void OnTick() {
    double rsi = TB_RSI(Close, 14, 0);
    double sma = TB_SMA(Close, 20, 0);
    // ... use indicators
}
```

## Next Steps

Proceed to **[10-testing.md](./10-testing.md)** for comprehensive testing strategies.
